from __future__ import annotations
import argparse
import pandas as pd
import numpy as np
from pathlib import Path

from ..utils.io_tools import read_series_csv
from ..utils.exog_tools import build_exog_matrix
from ..modeling.sarimax_exog import SarimaxExog
from ..modeling.ridge_exog import RidgeExog
from ..modeling.residual_ridge import ResidualRidge
from ..eval.backtesting import rolling_backtest
from ..utils.metrics import mape, smape, mase
from ..utils.stl_tools import stl_decompose

BASE_REGRESSORS = ["usdclp", "ipc", "diesel", "corn", "soy"]

def _fallback_forecast(y: pd.Series, h: int, seasonality: int = 12) -> pd.Series:
    y = y.dropna().astype(float)
    if len(y) == 0:
        return pd.Series([], dtype=float)
    last_ts = y.index[-1]
    future_idx = pd.date_range(last_ts + pd.offsets.MonthBegin(1), periods=h, freq="MS")
    if len(y) >= seasonality:
        tail = y.iloc[-seasonality:]
        vals = [float(tail.iloc[i % seasonality]) for i in range(h)]
    elif len(y) >= 2:
        slope = (y.iloc[-1] - y.iloc[0]) / (len(y) - 1)
        vals = y.iloc[-1] + slope * np.arange(1, h+1)
    else:
        vals = [float(y.iloc[-1])] * h
    return pd.Series(vals, index=future_idx)

def _seasonal_pattern(seasonal: pd.Series) -> pd.Series:
    pat = seasonal.groupby(seasonal.index.month).mean()
    pat.index = range(1, 13)
    return pat

def _load_align_series(path: str, target_idx: pd.DatetimeIndex) -> pd.Series:
    s = read_series_csv(path).asfreq("MS")
    s = s.reindex(pd.date_range(target_idx.min(), target_idx.max(), freq="MS")).ffill().bfill()
    return s

def _build_exog_aligned(y_index: pd.DatetimeIndex, paths: dict[str,str], lags: list[int], log_names: set[str]) -> pd.DataFrame | None:
    exog = {}
    for name, p in paths.items():
        if p:
            s = _load_align_series(p, y_index)
            if name in log_names:
                s = np.log(s.clip(lower=1e-9))
            exog[name] = s
    if not exog:
        return None
    tmp_y = pd.Series(index=y_index, dtype=float)
    X = build_exog_matrix(tmp_y, exog, lags=lags, log_transform=[])
    X = X.loc[y_index].ffill().bfill().dropna(axis=1, how="all")
    if X.shape[1] == 0:
        return None
    mu, sd = X.mean(), X.std(ddof=0).replace(0, 1.0)
    X = (X - mu) / sd
    X.attrs["scaler_mean"], X.attrs["scaler_std"] = mu, sd
    return X

def _bt_metrics_on_original(preds_deseas: pd.Series, y: pd.Series, seasonal: pd.Series, multiplicative: bool, seasonality: int):
    pat = _seasonal_pattern(seasonal)
    seas_bt = preds_deseas.index.to_series().dt.month.map(pat).astype(float)
    preds_orig = (preds_deseas * seas_bt.values) if multiplicative else (preds_deseas + seas_bt.values)
    y_true = y.reindex(preds_orig.index)
    return {"MAPE": mape(y_true, preds_orig), "sMAPE": smape(y_true, preds_orig), "MASE": mase(y, preds_orig, seasonality=seasonality)}

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--target", required=True)
    for r in BASE_REGRESSORS:
        ap.add_argument(f"--{r}", required=False)
    ap.add_argument("--lags", nargs="+", type=int, default=[1])
    ap.add_argument("--auto_lags", nargs="+", type=int, default=[])
    ap.add_argument("--seasonality", type=int, default=12)
    ap.add_argument("--h", type=int, default=2)
    ap.add_argument("--bt_init", type=int, default=12)
    ap.add_argument("--out", required=True)
    ap.add_argument("--multiplicative", action="store_true")
    args = ap.parse_args()

    # Target mensual
    y = read_series_csv(args.target).asfreq("MS")
    if y.isna().any():
        y = y.interpolate(limit_direction="both")
    if args.multiplicative and (y <= 0).any():
        eps = max(y[y > 0].min() * 0.1, 1e-6)
        y = y.clip(lower=eps)

    # STL
    n = len(y.dropna())
    min_for_stl = max(13, args.seasonality * 2 + 1)
    if n >= min_for_stl:
        try:
            if args.multiplicative:
                ylog = np.log(y)
                _, seasonal_log, _ = stl_decompose(ylog, period=args.seasonality, robust=True)
                seasonal = np.exp(seasonal_log)
                y_deseas = (y / seasonal).dropna()
                print(f"[STL] multiplicativa OK (n={n}, period={args.seasonality})")
            else:
                _, seasonal_add, _ = stl_decompose(y, period=args.seasonality, robust=True)
                seasonal = seasonal_add
                y_deseas = (y - seasonal).dropna()
                print(f"[STL] aditiva OK (n={n}, period={args.seasonality})")
        except Exception as e:
            print(f"[STL] Falló ({e}); sin STL.")
            seasonal = pd.Series(1.0 if args.multiplicative else 0.0, index=y.index)
            y_deseas = y.copy()
    else:
        print(f"[STL] Serie corta (n={n}<{min_for_stl}); sin STL.")
        seasonal = pd.Series(1.0 if args.multiplicative else 0.0, index=y.index)
        y_deseas = y.copy()

    # Exógenas
    paths = {r: getattr(args, r) for r in BASE_REGRESSORS}
    LOG_NAMES = {"usdclp","diesel","corn","soy"}
    def make_X(lags):
        return _build_exog_aligned(y_deseas.index, paths, lags=lags, log_names=LOG_NAMES)

    # Auto-lags para tener el mejor set de X para SARIMAX
    lags_to_try = [args.lags] if not args.auto_lags else [[x] for x in args.auto_lags] + [args.auto_lags]
    best_lags, best_mase, best_X, best_y = None, np.inf, None, None
    for L in lags_to_try:
        X = make_X(L)
        X_model = None if X is None else X.dropna()
        y_model = y_deseas if X_model is None else y_deseas.loc[X_model.index]
        n_d = len(y_model)
        init = max(6, min(n_d-1, args.bt_init))
        ok_bt = (n_d - args.h) >= init and init >= 6
        if not ok_bt:
            continue
        def builder_sarimax():
            return SarimaxExog(seasonal_period=args.seasonality,
                               pdq_grid=[(0,1,1),(1,1,0),(1,1,1)],
                               PDQ_grid=[(0,1,1),(1,1,0)],
                               trend=None)
        bt = rolling_backtest(y_model, X_model, builder_sarimax, horizon=1, initial_window=init, seasonality=args.seasonality)
        if "pred" in bt and not bt["pred"].empty:
            mets = _bt_metrics_on_original(bt["pred"], y, seasonal, args.multiplicative, args.seasonality)
            print(f"[BT] lags={L} -> MASE={float(mets['MASE']):.4f}")
            if float(mets["MASE"]) < best_mase:
                best_lags, best_mase, best_X, best_y = L, float(mets["MASE"]), X_model, y_model

    # Usa los mejores lags (o los fijados)
    if best_lags is None:
        X = make_X(args.lags)
        X_model = None if X is None else X.dropna()
        y_model = y_deseas if X_model is None else y_deseas.loc[X_model.index]
        print(f"[EXOG] lags={args.lags} usados (sin selección).")
    else:
        X_model, y_model = best_X, best_y
        print(f"[EXOG] selección auto-lags -> lags={best_lags} (MASE={best_mase:.4f})")

    # Backtest comparando: BASELINE vs SARIMAX vs RIDGE
    results = []
    init = max(6, min(len(y_model)-1, args.bt_init))
    can_bt = (len(y_model) - args.h) >= init and init >= 6

    def builder_sarimax():
        return SarimaxExog(seasonal_period=args.seasonality,
                           pdq_grid=[(0,1,1),(1,1,0),(1,1,1)],
                           PDQ_grid=[(0,1,1),(1,1,0)],
                           trend=None)
    def builder_ridge():
        return RidgeExog(alpha=1.0, ar_lags=(1,12))

    if can_bt:
        # SARIMAX exógeno
        bt1 = rolling_backtest(y_model, X_model, builder_sarimax, horizon=1, initial_window=init, seasonality=args.seasonality)
        if "pred" in bt1 and not bt1["pred"].empty:
            m1 = _bt_metrics_on_original(bt1["pred"], y, seasonal, args.multiplicative, args.seasonality)
            print(f"[BT][SARIMAX] Ventana inicial={init}, puntos={len(y_model)} -> (ORIG): {m1}")
            results.append(("sarimax", float(m1["MASE"]), y_model, X_model))

        # RIDGE ARX
        bt2 = rolling_backtest(y_model, X_model, builder_ridge, horizon=1, initial_window=init, seasonality=args.seasonality)
        if "pred" in bt2 and not bt2["pred"].empty:
            m2 = _bt_metrics_on_original(bt2["pred"], y, seasonal, args.multiplicative, args.seasonality)
            print(f"[BT][RIDGE ] Ventana inicial={init}, puntos={len(y_model)} -> (ORIG): {m2}")
            results.append(("ridge", float(m2["MASE"]), y_model, X_model))

        # BASELINE univariado (sin exógenas)
        init0 = max(6, min(len(y_deseas)-1, args.bt_init))
        if (len(y_deseas) - args.h) >= init0 and init0 >= 6:
            bt0 = rolling_backtest(y_deseas, None, builder_sarimax, horizon=1, initial_window=init0, seasonality=args.seasonality)
            if "pred" in bt0 and not bt0["pred"].empty:
                m0 = _bt_metrics_on_original(bt0["pred"], y, seasonal, args.multiplicative, args.seasonality)
                print(f"[BT][BASE  ] Ventana inicial={init0}, puntos={len(y_deseas)} -> (ORIG): {m0}")
                results.append(("baseline", float(m0["MASE"]), y_deseas, None))
    else:
        print(f"[BT] Sin backtest (n_d={len(y_model)}, init={init}); elegiré BASELINE por defecto.")
        results.append(("baseline", np.inf, y_deseas, None))

    # Elegir mejor por MASE
    chosen = min(results, key=lambda x: x[1]) if results else ("baseline", np.inf, y_deseas, None)
    print(f"[MODEL] elegido: {chosen[0]} (MASE={chosen[1]:.4f})")
            # Intento de booster de residuo sobre baseline/sarimax cuando hay X
            use_boost = (chosen[0] in ["baseline","sarimax"]) and (X_model is not None)

    y_final, X_final = chosen[2], chosen[3]

    # Ajuste final + pronóstico
    last_idx = y.index[-1]
    future_idx = pd.date_range(last_idx + pd.offsets.MonthBegin(1), periods=args.h, freq="MS")
    try:
        model = builder_ridge() if chosen[0]=="ridge" else builder_sarimax()
        model.fit(y_final, X_final)
        if X_final is not None:
            last_row = X_final.iloc[[-1]].to_numpy()
            X_future = pd.DataFrame(np.repeat(last_row, args.h, axis=0), index=future_idx, columns=X_final.columns)
        else:
            X_future = None
        deseas = model.forecast(steps=args.h, X_future=X_future)
            # Booster: ajustar sobre residuo in-sample y sumar al forecast
            try:
                if use_boost:
                    fitted_idx = y_final.index
                    fitted_in = None
                    if hasattr(model, 'res_') and hasattr(model.res_, 'fittedvalues'):
                        import pandas as pd
                        fv = pd.Series(model.res_.fittedvalues).reindex(fitted_idx)
                        fitted_in = fv
                    if fitted_in is not None:
                        resid = (y_final - fitted_in).dropna()
                        X_in = X_final.reindex(resid.index) if X_final is not None else None
                        if X_in is not None and X_in.shape[1] > 0:
                            rb = ResidualRidge(alpha=1.0).fit(resid, X_in)
                            import numpy as np, pandas as pd
                            last_row = X_final.iloc[[-1]].to_numpy()
                            Xf = pd.DataFrame(np.repeat(last_row, args.h, axis=0), index=future_idx, columns=X_final.columns)
                            resid_hat = rb.forecast(Xf)
                            deseas = deseas.add(resid_hat.reindex(deseas.index).fillna(0.0), fill_value=0.0)
                            print('[BOOST] ResidualRidge aplicado.')
            except Exception as e:
                print(f'[BOOST] Omitido ({e}).')
    except Exception as e:
        print(f"[FINAL] Falló ajuste ({e}); usando fallback baseline.")
        y_fb = y_final if len(y_final) > 0 else y
        deseas = _fallback_forecast(y_fb, args.h, seasonality=args.seasonality)

    # Volver a escala original
    pat = _seasonal_pattern(seasonal)
    seas_fut = pd.Series(future_idx.month, index=future_idx).map(pat).astype(float)
    y_forecast = (deseas * seas_fut.values) if args.multiplicative else (deseas + seas_fut.values)

    out = pd.Series(y_forecast, index=future_idx, name="forecast").to_frame()
    out["date"] = out.index
    out = out[["date","forecast"]]
    Path(args.out).parent.mkdir(parents=True, exist_ok=True)
    out.to_csv(args.out, index=False)
    print(f"Pronóstico guardado en {args.out}")

if __name__ == "__main__":
    main()
